// This is the build script for citop. It replaces an older
// Makefile that was harder to keep compatible with all
// target platforms without relying on specific building tools
// (e.g. GNU make).
//
// This script depends on the following external programs:
//  - go to build executables
//  - git for constructing the version number based
//  on the last tag and the current state of the repository
//  - pandoc for building the manual page in various
//  formats. See https://pandoc.org/installing.html for installation
//  instructions.
//  - tar for building gzipped binary archives
//
//
package main

import (
	"bytes"
	"crypto/sha256"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"strings"
)

const usage = `Usage:
        make             # Build executable and manual pages (requires pandoc)
        make releases    # Build release archives (requires pandoc)
        make clean       # Remove build directory
`

// Location of the directory where build artifacts are stored
const buildDirectory = "build"

// List of OS + architecture targets for releases
var OSesByArch = map[string][]string{
	"amd64": {"linux", "freebsd", "openbsd", "netbsd", "darwin"},
}

func version(env []string) (string, error) {
	gitVersion, err := gitDescribe()
	if err != nil {
		return "", err
	}

	goOs, goArch, err := GoOsAndArch(env)
	if err != nil {
		return "", err
	}

	return fmt.Sprintf("citop-%s-%s-%s", gitVersion, goOs, goArch), nil
}

// Build version number from last git tag
func gitDescribe() (string, error) {
	cmd := exec.Command("git", "describe", "--tags", "--dirty")
	bs, err := cmd.Output()
	if err != nil {
		return "", err
	}

	version := strings.Split(string(bs), "\n")[0]
	version = strings.Trim(version, "\r")
	return version, nil
}

func goBuild(version string, dir string, env []string) error {
	version = fmt.Sprintf("-X main.Version=%s", version)
	executable := path.Join(dir, "citop")
	fmt.Fprint(os.Stderr, fmt.Sprintf("Building %s...\n", executable))
	wd, err := os.Getwd()
	if err != nil {
		return err
	}
	cmd := exec.Command("go", buildDirectory, "-ldflags", version, "-o", executable, path.Join(wd, "cmd", "citop"))
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Env = append(os.Environ(), env...)
	return cmd.Run()
}

const manGoTemplate = `// Do not edit. This file was generated by the build script.
package main

import "strings"

const generated = ` + "`%s`" + `

func manualPage() string {
	return strings.Replace(generated, "\\<version\\>", Version, 1)
}
`

func man(version string, dir string) error {
	bs, err := ioutil.ReadFile("man.md")
	if err != nil {
		return err
	}

	markdown := strings.ReplaceAll(string(bs), "\\<version\\>", version)

	output := path.Join(dir, "citop.man.html")
	fmt.Fprint(os.Stderr, fmt.Sprintf("Building %s...\n", output))
	mdToHTML := exec.Command("pandoc", "-s", "-t", "html5", "--template", "pandoc_template.html", "-o", output)
	mdToHTML.Stdin = bytes.NewBufferString(markdown)
	mdToHTML.Stdout = os.Stdout
	mdToHTML.Stderr = os.Stderr
	if err := mdToHTML.Run(); err != nil {
		return err
	}

	stdout := &bytes.Buffer{}
	// FIXME Move this out of here and parametrize the path
	fmt.Fprint(os.Stderr, "Building cmd/citop/man.go...\n")
	mdToGo := exec.Command("pandoc", "-s", "-t", "man")
	mdToGo.Stdin = bytes.NewBufferString(markdown)
	mdToGo.Stdout = stdout
	mdToGo.Stderr = os.Stderr
	if err := mdToGo.Run(); err != nil {
		return err
	}
	manGo := fmt.Sprintf(manGoTemplate, strings.ReplaceAll(stdout.String(), "`", "\"` + \"`\" + `\""))
	if err := ioutil.WriteFile("cmd/citop/man.go", []byte(manGo), os.ModePerm); err != nil {
		return err
	}

	output = path.Join(dir, "citop.man.1")
	fmt.Fprint(os.Stderr, fmt.Sprintf("Building %s...\n", output))
	mdToRoff := exec.Command("pandoc", "-s", "-t", "man", "-o", output)
	mdToRoff.Stdin = bytes.NewBufferString(markdown)
	mdToRoff.Stdout = os.Stdout
	mdToRoff.Stderr = os.Stderr
	return mdToRoff.Run()
}

const licenseHeader = `Below is the license of citop and of every package it uses


===== github.com/nbedos/citop =====
`

func license(dir string) error {
	output := path.Join(dir, "LICENSE")
	fmt.Fprint(os.Stderr, fmt.Sprintf("Building %s...\n", output))
	b := strings.Builder{}
	b.WriteString(licenseHeader)
	bs, err := ioutil.ReadFile("LICENSE")
	if err != nil {
		return err
	}
	if _, err := b.Write(bs); err != nil {
		return err
	}

	goList := exec.Command("go", "list", "-f", "{{.Dir}}", "-m", "all")
	if bs, err = goList.Output(); err != nil {
		return err
	}

	for _, pkgPath := range strings.Split(string(bs), "\n") {
		if !strings.Contains(pkgPath, "citop") {
			licensePath := path.Join(pkgPath, "LICENSE")
			if bs, err = ioutil.ReadFile(licensePath); err == nil {
				b.WriteString("\n\n")
				s := path.Join("go", "pkg", "mod") + string([]rune{os.PathSeparator})
				if n := strings.Index(pkgPath, s); n >= 0 {
					pkgPath = pkgPath[n+len(s):]
				}
				b.WriteString(fmt.Sprintf("===== %s =====\n", pkgPath))
				b.Write(bs)
			}
		}
	}

	return ioutil.WriteFile(output, []byte(b.String()), os.ModePerm)
}

func GoOsAndArch(env []string) (string, string, error) {
	env = append(os.Environ(), env...)
	goEnvGOOS := exec.Command("go", "env", "GOOS")
	goEnvGOOS.Env = env
	bs, err := goEnvGOOS.Output()
	if err != nil {
		return "", "", err
	}
	GoOS := strings.Trim(string(bs), "\r\n")

	goEnvGOARCH := exec.Command("go", "env", "GOARCH")
	goEnvGOARCH.Env = env
	bs, err = goEnvGOARCH.Output()
	if err != nil {
		return "", "", err
	}
	GoArch := strings.Trim(string(bs), "\r\n")

	return GoOS, GoArch, nil
}

func build(workdir string, env []string) (string, error) {
	version, err := version(env)
	if err != nil {
		return "", err
	}
	archiveDir := version
	dir := path.Join(workdir, archiveDir)
	if err := os.MkdirAll(dir, os.ModePerm); err != nil {
		return "", err
	}
	if err := man(version, dir); err != nil {
		return "", err
	}
	if err := goBuild(version, dir, env); err != nil {
		return "", err
	}
	if err := license(dir); err != nil {
		return "", err
	}

	return archiveDir, nil
}

func compress(workdir string, dir string) (string, error) {
	archivePath := dir + ".tar.gz"
	fmt.Fprint(os.Stderr, fmt.Sprintf("Building %s...\n", path.Join(workdir, archivePath)))
	absoluteArchivePath := path.Join(workdir, archivePath)
	cmd := exec.Command("tar", "-C", workdir, "-czf", absoluteArchivePath, dir)
	return absoluteArchivePath, cmd.Run()
}

func hash(filepath string) (string, error) {
	bs, err := ioutil.ReadFile(filepath)
	if err != nil {
		return "", err
	}

	return fmt.Sprintf("%x", sha256.Sum256(bs)), nil
}

// Build binary release archives for all targets
func releases(dir string, OSesByArch map[string][]string) error {
	archives := make([]string, 0)
	for arch, OSes := range OSesByArch {
		for _, OS := range OSes {
			env := []string{
				fmt.Sprintf("GOOS=%s", OS),
				fmt.Sprintf("GOARCH=%s", arch),
			}

			archiveDir, err := build(dir, env)
			if err != nil {
				return err
			}

			archivePath, err := compress(dir, archiveDir)
			if err != nil {
				return err
			}
			archives = append(archives, archivePath)
		}
	}

	return releaseNotes(dir, archives)
}

func releaseNotes(dir string, archives []string) error {
	notes := path.Join(dir, "notes.md")
	fmt.Fprint(os.Stderr, fmt.Sprintf("Building %s...\n", notes))

	changelog, err := ioutil.ReadFile("CHANGELOG.md")
	if err != nil {
		return err
	}
	content := strings.Builder{}
	// Extract content between first and second occurrence of "## "
	delimiter := "## "
	parts := strings.SplitN(string(changelog), delimiter, 3)
	if len(parts) >= 2 {
		sectionWithHeader := parts[1]
		lines := strings.SplitN(sectionWithHeader, "\n", 2)
		changes := lines[len(lines)-1]
		content.WriteString("# Changes:\n")
		content.WriteString(changes)
	}

	content.WriteString("# Checksums")
	content.WriteString("\n\nfile | sha256sum\n---|---\n")
	for _, archive := range archives {
		h, err := hash(archive)
		if err != nil {
			return err
		}
		content.WriteString(fmt.Sprintf("%s | %s\n", path.Base(archive), h))
	}

	return ioutil.WriteFile(notes, []byte(content.String()), os.ModePerm)
}

func main() {
	if len(os.Args) < 1 || len(os.Args) > 2 {
		fmt.Fprint(os.Stderr, usage)
		os.Exit(1)
	}

	var err error
	if len(os.Args) == 1 {
		_, err = build(buildDirectory, nil)
	} else {
		switch os.Args[1] {
		case "releases":
			err = releases(buildDirectory, OSesByArch)
		case "clean":
			err = os.RemoveAll(buildDirectory)
		default:
			fmt.Fprint(os.Stderr, fmt.Sprintf("unknow command: %q\n", os.Args[1]))
			fmt.Fprint(os.Stderr, usage)
			os.Exit(1)
		}
	}

	if err != nil {
		fmt.Fprint(os.Stderr, err)
		os.Exit(1)
	}
}
